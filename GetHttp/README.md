# GetHttp

名前のとおり、HTTPプロトコルのGET通信を行い、データを取得するプログラムです。

# ソースコード解説

WindowsでC++用HTTP通信ライブラリというと「wininet」が恐らく最有力候補なのではないかと思われる（疎いので実際には知らない）が、自前実装がたのしい（？）C++なのだからDXライブラリの通信関数を使って自分で取得くらい書いてみよう、というサンプル。

## ライブラリ内部用の通信情報の削除

DXライブラリでHTTP通信、すなわちTCP/IPによる通信を行うためには GetNetWorkDataLength などの通信関数を用いる。
しかし、この関数は単にTCPで通信を行うだけの関数ではなく、DXライブラリプログラム間で用意に通信できるような仕組みがなされている。
具体的には送信情報の先頭に送信バイト数についての情報が埋め込まれており、そのまま普通のサーバとHTTPリクエストを行うと、通知用の余分な情報も送信してしまうためHTTP通信を行うことができない。

そこで `SetUseDXNetWorkProtocol(FALSE)` でこの通知用情報をカットする。
この関数を使うと通知用情報をカットすることができ、ちゃんとHTTPのリクエストを送ることが可能になる。
しかし、この関数を使うと通信関連の一部の関数の挙動が代わってしまう（受信バイト数を見ながらループしなきゃいけなくなる感じ）ので、公式のサンプルに関数を突っ込むだけでは動かず、ループ周りの仕組みをちゃんと整える必要がある。

参考：http://hpcgi2.nifty.com/natupaji/bbs/patio.cgi?mode=past&no=736&p=2

## ホスト名からIPアドレスを取得する方法

```cpp
const TCHAR serverName[] = TEXT("homepage2.nifty.com");

IPDATA ipAddress;

GetHostIPbyName(serverName, &ipAddress);
```

この際、ホスト名にプロトコル名（httpとか）を入れる必要はないので注意。

## 受信バイト数について

`SetUseDXNetWorkProtocol(FALSE)` を適用させた場合、 `GetNetWorkDataLength(netHandle)` の戻り値が「バッファに溜まっているバイト数」ではなく、「読み取れるデータがあるか否かのフラグ」に変化する。
その為、 `GetNetWorkDataLength(netHandle)` の戻り値を使って受信バイト数を確認することができなくなる。

この場合は `NetWorkRecv(netHandle, strBuf, requireLength)` でとりあえずデータを読み込み、この関数の戻り値から実際に受信したバイト数を判断する。
しかし、この関数には２点ほどやっかいな点がある。
一つ目は受信し始めの時はエラーになってしまい、戻り値が -1 になってしまうこと。
この場合は受信データを弄る前にエラー処理を行えば良いが、エラーだからといってループを抜けさせるとほぼ絶対データが受信できなくなってしまう（少し時間をおけば大丈夫かも）ので、ここでは `continue` を使うこと。

もう一つもエラー関係だがこちらはもっと厄介。
`NetWorkRecv` は受信するバイト数を第３引数( `requireLength` )で指定するが、実際に読み込むことが出来る値よりこの値が大きいと関数はエラーを発生させる。
似たような指定方法の関数にMSVCの `○○_s` 関数群(このコード中でも `sprintf_s` を利用している)があるが、そちらは「最大読み取り数」を指定するのに対して、こちらは「読み取りたいバイト数」を指定するものになっているのである。
安牌だと思って安易に大きな値を指定すると全然データを取得してくれなくなってしまう。

しかし１バイトずつ読んでいくと当然ながらすごい時間がかかる。
そこでこのコード中では「受信が連続して成功してれば１回の読み取りバイト数を増やし、失敗が続けば読み取りバイト数を減らす」という処理を加えている。
こうすることで徐々に大きなバイト数を読み込み始められるし、最後の方に読み取れるバイト数が少くなっても最終的には1バイト単位になるので読み込める、という算段。
正直、これで良いのかは知らないのでもうちょっと良い方法を探したい。

```cpp
// データ受信し、読み込んだ分をサイズに増やす
readLength = NetWorkRecv(netHandle, strBuf, requireLength);

// 読み取りエラー
// 待機時の他にバッファ内に溜まっている文字数よりも requireLength が大きい時も -1 になるので注意
if (readLength == -1)
{
	if (--successCount <= -updateCount)
	{
		if (--requireLength == 0)
			requireLength = 1;
		successCount = 0;
		// バッファに溜まるように適当に待機
		WaitTimer(1000);
	}
	continue;
}
// 規定回数読み取りが成功したら読み取り文字数を増やす
if (++successCount >= updateCount)
{
	++requireLength;
	successCount = 0;
}
```